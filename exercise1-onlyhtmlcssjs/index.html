<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Snake</title>
    <style>
      :root {
        --bg: #0b0f14;
        --panel: #111827;
        --text: #e5e7eb;
        --muted: #9ca3af;
        --accent: #34d399;
        --accent-2: #22d3ee;
        --danger: #ef4444;
        --grid: #1f2937;
        --snake: #10b981;
        --snake-head: #34d399;
        --food: #f59e0b;
        --shadow: rgba(0,0,0,0.35);
      }

      html, body {
        height: 100%;
      }

      body {
        margin: 0;
        background: radial-gradient(1200px 800px at 60% -10%, #0e1622 0%, var(--bg) 60%);
        color: var(--text);
        font: 500 16px/1.4 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji";
        display: grid;
        place-items: center;
      }

      main#app {
        width: min(92vw, 560px);
        display: grid;
        gap: 12px;
      }

      header#hud {
        display: grid;
        grid-template-columns: 1fr auto auto;
        gap: 8px 12px;
        align-items: center;
        background: linear-gradient(180deg, #0f172a, var(--panel));
        border: 1px solid #1f2a44;
        padding: 10px 12px;
        border-radius: 12px;
        box-shadow: 0 10px 30px var(--shadow), inset 0 1px 0 rgba(255,255,255,0.04);
      }

      #hud .kpi {
        display: inline-flex;
        gap: 8px;
        align-items: baseline;
        color: var(--muted);
        user-select: none;
      }

      #hud .kpi strong {
        color: var(--text);
        letter-spacing: 0.3px;
      }

      .actions {
        display: inline-flex;
        gap: 8px;
        justify-self: end;
      }

      button {
        appearance: none;
        border: 1px solid #23314f;
        background: linear-gradient(180deg, #152036, #0f172a);
        color: var(--text);
        padding: 8px 12px;
        border-radius: 10px;
        cursor: pointer;
        transition: transform 120ms ease, border-color 120ms ease, background 120ms ease;
      }

      button:hover { border-color: #315086; }
      button:active { transform: translateY(1px); }

      .primary {
        border-color: #0f766e;
        background: linear-gradient(180deg, #0b3a38, #0b2b29);
      }

      .danger {
        border-color: #7f1d1d;
        background: linear-gradient(180deg, #3a0b0b, #2b0b0b);
        color: #fecaca;
      }

      .board-wrap {
        position: relative;
        background: linear-gradient(180deg, #0b1220, #0a1019);
        border: 1px solid #14213a;
        border-radius: 14px;
        padding: 10px;
        box-shadow: 0 14px 45px var(--shadow), inset 0 1px 0 rgba(255,255,255,0.04);
      }

      canvas#board {
        width: 100%;
        height: auto;
        display: block;
        border-radius: 10px;
        background: #0a0f1a;
        image-rendering: pixelated;
      }

      .overlay {
        position: absolute;
        inset: 10px;
        display: grid;
        place-items: center;
        pointer-events: none;
      }

      .badge {
        background: rgba(0,0,0,0.55);
        border: 1px solid rgba(255,255,255,0.08);
        padding: 10px 12px;
        border-radius: 999px;
        color: var(--muted);
        font-size: 14px;
        letter-spacing: 0.3px;
        user-select: none;
      }

      .help {
        text-align: center;
        color: var(--muted);
        font-size: 12px;
        margin-top: 4px;
        user-select: none;
      }

      @media (max-width: 420px) {
        header#hud { grid-template-columns: 1fr 1fr; }
        .actions { grid-column: span 2; justify-self: start; }
      }
    </style>
  </head>
  <body>
    <main id="app">
      <header id="hud">
        <div class="kpi">Score: <strong id="score">0</strong></div>
        <div class="kpi">Best: <strong id="best">0</strong></div>
        <div class="actions">
          <button id="toggle" class="primary" title="Space or P">Pause</button>
          <button id="restart" class="danger" title="R">Restart</button>
        </div>
      </header>

      <div class="board-wrap">
        <canvas id="board" width="480" height="480" aria-label="Snake game board" role="img"></canvas>
        <div class="overlay">
          <span id="status" class="badge">Press Arrow Keys or WASD to start</span>
        </div>
      </div>

      <div class="help">
        Keys: Arrows/WASD to move • Space/P to pause • R to restart
      </div>
    </main>

    <script>
      (function () {
        const board = document.getElementById('board');
        const ctx = board.getContext('2d');
        const scoreEl = document.getElementById('score');
        const bestEl = document.getElementById('best');
        const toggleBtn = document.getElementById('toggle');
        const restartBtn = document.getElementById('restart');
        const statusBadge = document.getElementById('status');

        // --- Constants
        const GRID_SIZE = 20;               // 20x20 grid
        const TICK_MS_DEFAULT = 120;        // base tick speed
        const MIN_TICK_MS = 70;             // cap speed-up
        const SPEEDUP_EVERY = 5;            // speed up every 5 foods
        const SPEEDUP_DELTA = 5;            // 5ms faster each speedup

        const Keys = {
          ArrowUp: { x: 0, y: -1 },
          ArrowDown: { x: 0, y: 1 },
          ArrowLeft: { x: -1, y: 0 },
          ArrowRight: { x: 1, y: 0 },
          w: { x: 0, y: -1 }, W: { x: 0, y: -1 },
          s: { x: 0, y: 1 },  S: { x: 0, y: 1 },
          a: { x: -1, y: 0 }, A: { x: -1, y: 0 },
          d: { x: 1, y: 0 },  D: { x: 1, y: 0 },
        };

        // --- State
        /** @type {{x:number,y:number}[]} */
        let snake = [];
        /** @type {{x:number,y:number}} */
        let dir = { x: 1, y: 0 };
        /** @type {{x:number,y:number}} */
        let nextDir = { x: 1, y: 0 };
        /** @type {{x:number,y:number}} */
        let food = { x: 10, y: 10 };
        let score = 0;
        let best = 0;
        let tickMs = TICK_MS_DEFAULT;
        let started = false;
        let paused = false;
        let gameOver = false;
        let timer = null;

        // --- Helpers
        function randInt(max) { return Math.floor(Math.random() * max); }
        function coordsEq(a, b) { return a.x === b.x && a.y === b.y; }
        function snakeIncludes(x, y) { return snake.some(s => s.x === x && s.y === y); }
        function withinBounds(x, y) { return x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE; }

        function setBadge(text, color) {
          statusBadge.textContent = text;
          statusBadge.style.display = text ? 'inline-block' : 'none';
          statusBadge.style.color = color || '';
        }

        function loadBest() {
          try {
            const v = localStorage.getItem('snake.best');
            best = v ? Math.max(0, Number(v) || 0) : 0;
          } catch (_) { best = 0; }
          bestEl.textContent = String(best);
        }

        function saveBest() {
          if (score > best) {
            best = score;
            bestEl.textContent = String(best);
            try { localStorage.setItem('snake.best', String(best)); } catch (_) {}
          }
        }

        function setupCanvas() {
          const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
          const logical = Math.min(board.clientWidth || 480, 560 - 20);
          const size = Math.round(logical);
          const cell = Math.floor(size / GRID_SIZE);
          const renderSize = cell * GRID_SIZE; // ensure multiples to avoid blur

          board.width = renderSize * dpr;
          board.height = renderSize * dpr;
          board.style.width = renderSize + 'px';
          board.style.height = renderSize + 'px';
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }

        function resetGame() {
          started = false; paused = false; gameOver = false;
          score = 0; scoreEl.textContent = '0';
          tickMs = TICK_MS_DEFAULT; nextDir = { x: 1, y: 0 }; dir = { x: 1, y: 0 };
          const mid = Math.floor(GRID_SIZE / 2);
          snake = [ { x: mid - 1, y: mid }, { x: mid - 2, y: mid } ];
          spawnFood();
          setBadge('Press Arrow Keys or WASD to start');
          toggleBtn.textContent = 'Pause';
        }

        function spawnFood() {
          let x, y;
          do {
            x = randInt(GRID_SIZE);
            y = randInt(GRID_SIZE);
          } while (snakeIncludes(x, y));
          food = { x, y };
        }

        function startIfNeeded() {
          if (!started && !gameOver) {
            started = true;
            setBadge('');
            startLoop();
          }
        }

        function startLoop() {
          stopLoop();
          timer = setInterval(tick, tickMs);
        }

        function stopLoop() {
          if (timer) { clearInterval(timer); timer = null; }
        }

        function setPaused(p) {
          if (gameOver) return;
          paused = p;
          if (paused) {
            stopLoop();
            setBadge('Paused (Space/P to resume)');
            toggleBtn.textContent = 'Resume';
          } else {
            setBadge('');
            toggleBtn.textContent = 'Pause';
            startLoop();
          }
        }

        function onKeyDown(e) {
          const k = e.key;
          if (k === ' ' || k === 'p' || k === 'P') {
            e.preventDefault();
            if (!started) { startIfNeeded(); return; }
            setPaused(!paused);
            return;
          }
          if (k === 'r' || k === 'R') { e.preventDefault(); resetGame(); draw(); return; }

          // Direction controls
          if (Keys[k]) {
            e.preventDefault();
            const d = Keys[k];
            // prevent 180° reversal
            if (snake.length > 1 && (d.x === -dir.x && d.y === -dir.y)) {
              return;
            }
            nextDir = d;
            startIfNeeded();
          }
        }

        function maybeSpeedUp() {
          if (score > 0 && score % SPEEDUP_EVERY === 0) {
            const next = Math.max(MIN_TICK_MS, tickMs - SPEEDUP_DELTA);
            if (next !== tickMs) {
              tickMs = next;
              if (!paused && !gameOver) { startLoop(); }
            }
          }
        }

        function tick() {
          if (paused || gameOver) return;
          dir = nextDir;
          const head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };

          // collisions
          if (!withinBounds(head.x, head.y) || snakeIncludes(head.x, head.y)) {
            gameOver = true;
            stopLoop();
            saveBest();
            setBadge('Game Over — Press R to restart', '#fecaca');
            return;
          }

          const ate = coordsEq(head, food);
          snake.unshift(head);
          if (ate) {
            score += 1; scoreEl.textContent = String(score);
            spawnFood();
            maybeSpeedUp();
          } else {
            snake.pop();
          }

          draw();
        }

        function draw() {
          const size = board.width / Math.max(1, Math.floor(window.devicePixelRatio || 1));
          const cell = Math.floor(size / GRID_SIZE);
          const w = cell * GRID_SIZE;
          const h = w;

          // clear
          ctx.clearRect(0, 0, w, h);

          // grid background
          ctx.fillStyle = '#0b1220';
          ctx.fillRect(0, 0, w, h);

          // draw subtle grid
          ctx.strokeStyle = 'rgba(255,255,255,0.05)';
          ctx.lineWidth = 1;
          for (let i = 0; i <= GRID_SIZE; i++) {
            const p = i * cell + 0.5;
            ctx.beginPath();
            ctx.moveTo(p, 0); ctx.lineTo(p, h); ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, p); ctx.lineTo(w, p); ctx.stroke();
          }

          // food
          ctx.fillStyle = getFoodColor();
          roundRectFill(food.x * cell, food.y * cell, cell, cell, Math.max(3, Math.floor(cell * 0.25)));

          // snake body
          for (let i = snake.length - 1; i >= 0; i--) {
            const seg = snake[i];
            const isHead = i === 0;
            ctx.fillStyle = isHead ? '#34d399' : '#10b981';
            roundRectFill(seg.x * cell, seg.y * cell, cell, cell, isHead ? Math.max(4, Math.floor(cell * 0.28)) : Math.max(3, Math.floor(cell * 0.22)));
          }
        }

        function getFoodColor() {
          // slight pulse
          const t = Date.now() * 0.004;
          const a = (Math.sin(t) * 0.25 + 0.75).toFixed(2);
          return `rgba(245, 158, 11, ${a})`;
        }

        function roundRectFill(x, y, w, h, r) {
          const rr = Math.min(r, w/2, h/2);
          ctx.beginPath();
          ctx.moveTo(x + rr, y);
          ctx.arcTo(x + w, y, x + w, y + h, rr);
          ctx.arcTo(x + w, y + h, x, y + h, rr);
          ctx.arcTo(x, y + h, x, y, rr);
          ctx.arcTo(x, y, x + w, y, rr);
          ctx.closePath();
          ctx.fill();
        }

        // --- Events
        window.addEventListener('resize', () => { setupCanvas(); draw(); });
        window.addEventListener('keydown', onKeyDown, { passive: false });
        toggleBtn.addEventListener('click', () => {
          if (!started) { startIfNeeded(); return; }
          setPaused(!paused);
        });
        restartBtn.addEventListener('click', () => { resetGame(); draw(); });

        // --- Init
        loadBest();
        setupCanvas();
        resetGame();
        draw();
      })();
    </script>
  </body>
</html>


